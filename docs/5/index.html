<!DOCTYPE html>
<html lang="en-us">

  <head>
  <!---
  <link href="http://gmpg.org/xfn/11" rel="profile">
  -->
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      soultoxik-web &middot; 
    
  </title>

  
      
  <link rel="canonical" href="../5/index.html">
      
  

  <link rel="stylesheet" href="../css/poole.css">
  <link rel="stylesheet" href="../css/syntax.css">
  <link rel="stylesheet" href="../css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="https://github.com/kika/fixedsys/releases/download/v3.02.9/FSEX302-alt.ttf">
  <!---
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="{{ '/public/apple-touch-icon-precomposed.png' | absolute_url }}">
  <link rel="shortcut icon" href="{{ '/public/favicon.ico' | absolute_url }}">
  -->

  <link rel="alternate" type="application/rss+xml" title="RSS" href="../atom.xml">

  <!--- deactivate google analytics
  {% if site.google_analytics_id %}
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '{{ site.google_analytics_id }}', 'auto');
    ga('send', 'pageview');
  </script>
  {% endif %}
  -->
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>soultoxik-web</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href>Home</a>

    <!--- The code below dynamically generates a sidebar nav of the files in the folder /pages -->

    
      
        <a class="sidebar-nav-item" href="../pages/About.html">About</a>
      
    
      
        <a class="sidebar-nav-item" href="../pages/Contact.html">Contact</a>
      
    

    <a class="sidebar-nav-item" href="../archive.html">Archive</a>

    <a class="sidebar-nav-item" href="https://github.com/soultoxik/soultoxik.github.io">GitHub project</a>

  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
    <p>
        <img src="../images/haskell-logo.png" class="logo" style="display: inline;" />
        Site created with
        <a href="https://jaspervdj.be/hakyll">Hakyll</a>.
        <br>
        Modified theme
        <a href="https://github.com/hahey/lanyon-hakyll">lanyon-hakyll</a>
        based on
        <a href="https://lanyon.getpoole.com/">Lanyon</a>.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href title="Home">soultoxik-web</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
          <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="../posts/2021-11-16-cccc.html">
        cccc snippet
      </a>
    </h1>
    <span class="post-date">November 16, 2021,
      
    </span>

    <p>Сниппет для <code>сссс</code> — проехаться по всему проекту</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">find</span> . -name <span class="st">&quot;*.h&quot;</span> -o -name <span class="st">&quot;*.cpp&quot;</span> -o -name <span class="st">&quot;*.cc&quot;</span> <span class="kw">|</span> <span class="fu">xargs</span> -t cccc</span></code></pre></div>
<hr />
<p>Snippet for <code>cccc</code> — process the entire project:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">find</span> . -name <span class="st">&quot;*.h&quot;</span> -o -name <span class="st">&quot;*.cpp&quot;</span> -o -name <span class="st">&quot;*.cc&quot;</span> <span class="kw">|</span> <span class="fu">xargs</span> -t cccc  </span></code></pre></div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="../posts/2021-11-04-qcom.html">
        qcom ondevice inference
      </a>
    </h1>
    <span class="post-date">November  4, 2021,
      
    </span>

    <p>Кажется Qualcomm дропнула поддержку программируемого DSP чего-либо выше 855. В sdk / веб доках о них ни слова, все форумы завалены вопросами на эту тему :)</p>
<p>В принципе некоторые свёрточные сети и так не показывали чудеса перформанса на DSP, то есть OpenCL бекенд всё ещё скорее всего best in class, но затея с AIP (когда части сетки выполняются на CPU/GPU/DSP в зависимости от типа слоёв) выглядела богато.</p>
<hr />
<p>It seems Qualcomm has dropped support for the programmable DSP in anything above the 855. There’s not a word about it in the SDK or web documentation, and all the forums are flooded with questions on this topic :)</p>
<p>In principle, some convolutional networks didn’t show performance miracles on the DSP anyway, meaning the OpenCL backend is still most likely best in class. But the idea behind AIP (where parts of the graph are executed on the CPU/GPU/DSP depending on the layer types) sounded rich/impressive.</p>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="../posts/2021-11-02-tuples.html">
        Tuples
      </a>
    </h1>
    <span class="post-date">November  2, 2021,
      
    </span>

    <p>Пусть есть std::tuple на разных классов, некоторые из которых шейрят некий статический интерфейс (пусть это будет поле int foo, подтянутый наследованием из Base).</p>
<p>Мы хотим для всех объектов таких классов применить какое-то действие, например проинициировать (опустим другие, более адекватные способы сделать конкретно это). inb4 — c++17, без концептов</p>
<p>Давайте используем следующий пассаж:</p>
<ol type="1">
<li>определим предикат поля и завернём его в функтор</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">using</span> <span class="dt">foo_present_t</span> = <span class="kw">decltype</span>(<span class="bu">std::</span>declval&lt;T&amp;&gt;().foo);</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="dt">has_foo_t</span> = <span class="bu">std::</span>experimental<span class="bu">::</span>is_detected_v&lt;<span class="dt">foo_present_t</span>, T&gt;;</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="kw">struct</span> hasFooPredicate {</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="kw">constexpr</span> <span class="at">static</span> <span class="kw">auto</span> value = <span class="dt">has_foo_t</span>&lt;T&gt;;</span>
<span id="cb1-10"><a href="#cb1-10"></a>    };</span></code></pre></div>
<ol start="2" type="1">
<li>определим функтор нашего действия</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>    <span class="kw">class</span> FooApplier {</span>
<span id="cb2-2"><a href="#cb2-2"></a>        <span class="dt">void</span> apply(Base* base) {</span>
<span id="cb2-3"><a href="#cb2-3"></a>            base-&gt;foo = <span class="dv">42</span>;</span>
<span id="cb2-4"><a href="#cb2-4"></a>        }</span>
<span id="cb2-5"><a href="#cb2-5"></a>    };</span></code></pre></div>
<ol start="3" type="1">
<li>определим вспомогательный класс который будет дёргать функтор и ехать по тюплу дальше</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id, <span class="kw">typename</span> IterableTypesTuple&gt;</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">struct</span> BulkApplier;</span></code></pre></div>
<p>где: * <code>TypesTuple</code> — наш исходный тюпл * <code>IterableTypesTuple</code> — тюпл листа типов, по которым ходим через head/tail * <code>Predicate</code> — наш предикат * <code>Id</code> — указатель на объект в тюпле 4. сформируем базу и индукцию этого класса * когда элементов нет — ничего не делаем</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id&gt;</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">struct</span> BulkApplier&lt;TypesTuple, Applier, Predicate, Id, <span class="bu">std::</span>tuple&lt;&gt;&gt; {</span>
<span id="cb4-3"><a href="#cb4-3"></a>        <span class="dt">void</span> apply(TypesTuple _) { }</span>
<span id="cb4-4"><a href="#cb4-4"></a>    };</span></code></pre></div>
<ul>
<li>когда есть — проверим предикат и в случае успеха дёрнем действие; в любом случае едем дальше</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id, <span class="kw">typename</span> Head, <span class="kw">typename</span> ...Tail&gt;</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">struct</span> BulkApplier&lt;TypesTuple, Applier, Condition, Id, <span class="bu">std::</span>tuple&lt;Head, Tail...&gt;&gt; {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dt">void</span> apply(TypesTuple args) {</span>
<span id="cb5-4"><a href="#cb5-4"></a>        <span class="cf">if</span> <span class="kw">constexpr</span>(Predicate&lt;<span class="bu">std::</span>tuple_element_t&lt;Id, TypesTuple&gt;&gt;::value) {</span>
<span id="cb5-5"><a href="#cb5-5"></a>            Applier{}.apply(&amp;<span class="bu">std::</span>get&lt;Id&gt;(nodes));</span>
<span id="cb5-6"><a href="#cb5-6"></a>        }</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a>        BulkApplier&lt;TypesTuple, Applier, Predicate, Id + <span class="dv">1</span>, <span class="bu">std::</span>tuple&lt;Tail...&gt;&gt;{}.apply(nodes);</span>
<span id="cb5-9"><a href="#cb5-9"></a>        }</span>
<span id="cb5-10"><a href="#cb5-10"></a>    };</span></code></pre></div>
<ol start="5" type="1">
<li>добавим вспомогательную функцию для этого всего беспредела</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate&gt;</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="dt">void</span> bulkApply(TypesTuple ) {</span>
<span id="cb6-3"><a href="#cb6-3"></a>        ulkApplier&lt;AllNodes, Applier, Condition, <span class="dv">0</span>, AllNodes&gt;{}.apply(allNodes);</span>
<span id="cb6-4"><a href="#cb6-4"></a>    }</span></code></pre></div>
<p>Как этим всем добром пользоваться:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a>    <span class="kw">auto</span> args = <span class="bu">std::</span>make_tuple(...);</span>
<span id="cb7-2"><a href="#cb7-2"></a>    bulkApply&lt;<span class="kw">decltype</span>(args), FooApplier, hasFooPredicate&gt;(args);</span></code></pre></div>
<p>PS: Этот механизм отлично обобщается, но это уже другая история</p>
<hr />
<p>Let’s say we have a <code>std::tuple</code> containing objects of different classes, some of which share a certain static interface (let’s say an <code>int foo</code> field, inherited from a <code>Base</code> class).</p>
<p>We want to apply some action to all such objects, for example, initialize them (let’s skip other more adequate ways to do this specifically). <em>inb4</em> — C++17, no concepts.</p>
<p>Let’s use the following approach:</p>
<ol type="1">
<li>Define a field predicate and wrap it in a functor.</li>
</ol>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">using</span> <span class="dt">foo_present_t</span> = <span class="kw">decltype</span>(<span class="bu">std::</span>declval&lt;T&amp;&gt;().foo);</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="dt">has_foo_t</span> = <span class="bu">std::</span>experimental<span class="bu">::</span>is_detected_v&lt;<span class="dt">foo_present_t</span>, T&gt;;</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="kw">struct</span> hasFooPredicate {</span>
<span id="cb8-9"><a href="#cb8-9"></a>      <span class="kw">constexpr</span> <span class="at">static</span> <span class="kw">auto</span> value = <span class="dt">has_foo_t</span>&lt;T&gt;;</span>
<span id="cb8-10"><a href="#cb8-10"></a>    };</span></code></pre></div>
<ol start="2" type="1">
<li>Define our action functor.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>    <span class="kw">class</span> FooApplier {</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="kw">public</span>: </span>
<span id="cb9-3"><a href="#cb9-3"></a>        <span class="dt">void</span> apply(Base* base) {</span>
<span id="cb9-4"><a href="#cb9-4"></a>            base-&gt;foo = <span class="dv">42</span>;</span>
<span id="cb9-5"><a href="#cb9-5"></a>        }</span>
<span id="cb9-6"><a href="#cb9-6"></a>    };</span></code></pre></div>
<ol start="3" type="1">
<li>Define a helper class that will call the functor and traverse the tuple.</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id, <span class="kw">typename</span> IterableTypesTuple&gt;</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">struct</span> BulkApplier;</span></code></pre></div>
<p>Where: * <code>TypesTuple</code> — our original tuple * <code>IterableTypesTuple</code> — the type list tuple we iterate over using head/tail * <code>Predicate</code> — our predicate * <code>Id</code> — index of the current element in the tuple</p>
<ol start="4" type="1">
<li>Implement the base and inductive cases for this class.</li>
</ol>
<ul>
<li>When there are no elements left — do nothing.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id&gt;</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">struct</span> BulkApplier&lt;TypesTuple, Applier, Predicate, Id, <span class="bu">std::</span>tuple&lt;&gt;&gt; {</span>
<span id="cb11-3"><a href="#cb11-3"></a>        <span class="dt">void</span> apply(TypesTuple _) { }</span>
<span id="cb11-4"><a href="#cb11-4"></a>    };</span></code></pre></div>
<ul>
<li>When elements exist — check the predicate and if successful, call the action; always proceed to the next element.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate, <span class="dt">int</span> Id, <span class="kw">typename</span> Head, <span class="kw">typename</span> ...Tail&gt;</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">struct</span> BulkApplier&lt;TypesTuple, Applier, Predicate, Id, <span class="bu">std::</span>tuple&lt;Head, Tail...&gt;&gt; { </span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">void</span> apply(TypesTuple nodes) { </span>
<span id="cb12-4"><a href="#cb12-4"></a>        <span class="cf">if</span> <span class="kw">constexpr</span>(Predicate&lt;<span class="bu">std::</span>tuple_element_t&lt;Id, TypesTuple&gt;&gt;::value) {</span>
<span id="cb12-5"><a href="#cb12-5"></a>            Applier{}.apply(&amp;<span class="bu">std::</span>get&lt;Id&gt;(nodes));</span>
<span id="cb12-6"><a href="#cb12-6"></a>        }</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>        BulkApplier&lt;TypesTuple, Applier, Predicate, Id + <span class="dv">1</span>, <span class="bu">std::</span>tuple&lt;Tail...&gt;&gt;{}.apply(nodes);</span>
<span id="cb12-9"><a href="#cb12-9"></a>        }</span>
<span id="cb12-10"><a href="#cb12-10"></a>    };</span></code></pre></div>
<ol start="5" type="1">
<li>Add a helper function for this entire mechanism.</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> TypesTuple, <span class="kw">typename</span> Applier, <span class="kw">template</span>&lt;<span class="kw">typename</span>&gt; <span class="kw">typename</span> Predicate&gt;</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="dt">void</span> bulkApply(TypesTuple allNodes) { </span>
<span id="cb13-3"><a href="#cb13-3"></a>        BulkApplier&lt;TypesTuple, Applier, Predicate, <span class="dv">0</span>, TypesTuple&gt;{}.apply(allNodes); </span>
<span id="cb13-4"><a href="#cb13-4"></a>    }</span></code></pre></div>
<p>How to use this machinery:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a>    <span class="kw">auto</span> args = <span class="bu">std::</span>make_tuple(...);</span>
<span id="cb14-2"><a href="#cb14-2"></a>    bulkApply&lt;<span class="kw">decltype</span>(args), FooApplier, hasFooPredicate&gt;(args);</span></code></pre></div>
<p>PS: This mechanism generalizes perfectly, but that’s another story.</p>
  </div>
  
</div>

<div class="pagination">
  
      <a class="pagination-item newer" href="../4/index.html">Newer</a>
  
  
    <span class="pagination-item older">Older</span>
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="../public/js/script.js"></script>

  </body>

</html>
